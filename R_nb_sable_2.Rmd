---
title: "R Notebook"
output: html_notebook
---
FIRST: run the stats_proj_sablefish scriptfile.

For some reason, it's not working well with Rnotebook.

So, run that scriptfile first, and now I'll try working in R notebook.


Treat the data as geostatisitcal data
conduct a Spatial Logistic Regression
and use the spBayes package

My datafile name is: Sable_geo

So, logistic regression means we either use 0 or 1 for the data. I think I'll need to manipulate the Sable_geo data to reflect this.

```{r}
names(Sable_geo)
Sable_geo$data
length(Sable_geo$data)

#I can do this with a for loop.. or with mutate
Sable_geo_df_2 <- as.data.frame(Sable_geo)
Sable_geo_df_binary <- Sable_geo_df_2 %>% mutate(data = ifelse(data>0, 1, 0))
length(Sable_geo_df_binary$data)

Sable_geo_binary <- as.geodata(Sable_geo_df_binary)
##warning that there's some overlapping locations. I shold think about getting rid of duplicates?
```


Ok so now I have a binary dataframe and binary geodataframe. We can do logistic regression on this...
It uses the logit tranformation


Might be useful to do this as bayes and not based methods
Where's my plot of alaska??
IDK
There's a ggplot way.
I think I can skip this
Reference: https://hughst.github.io/week-6/


Ooh, I do make a model!
A linear model or a glm?
GLM
```{r}
names(Sable_geo_df_binary)
glm_mod_1 <- glm(data ~ LONGITUDE + LATITUDE, data=Sable_geo_df_binary, family=binomial())
summary(glm_mod_1)

#ggplot() + geom_point(aes(glm_mod_1$fitted, Sable_geo_df_binary$data))
```
I think glms are not in bayes though
Looks like there are spatial trends

```{r}

```


AND I need to check for spatial autocorrelation


OK... Trying spbayes
```{r}
library(spBayes)

```

Which fucntions do I need?
spMvGLm fits multivariate Bayesian generalized linear spatioal regression models
-> might be this one

spGLM - > best one yet. OR GLM USE THIS ONE!!

```{r}
?spGLM
#how to do a spatial logitic regression with this thoug?
#phi <-
#sigma_sq <-

```


Before I do this tho, I think I need to go through the process where I esitmate a phi and sigma squared without using bayesian techniques. I think this is HW 3 and 4, with scallops and wolfcamp
FREQUENTIST WORLDVIEW
```{r}
#fit a logistic model?
sable_glm_trend_1 <- glm(data ~ LONGITUDE + LATITUDE, data=Sable_geo_df_binary, family=binomial(link=logit))

sable_glm_1_int <-  glm(data ~ LONGITUDE + LATITUDE + LONGITUDE:LATITUDE, data=Sable_geo_df_binary, family=binomial(link=logit))

sable_glm_trend_2_int <- glm(data ~ LONGITUDE + LATITUDE + I(LONGITUDE^2) + I(LATITUDE^2) + LONGITUDE:LATITUDE, data=Sable_geo_df_binary, family=binomial(link=logit))

sable_glm_2_noint <- glm(data ~ LONGITUDE + LATITUDE + I(LONGITUDE^2) + I(LATITUDE^2) , data=Sable_geo_df_binary, family=binomial(link=logit))

sable_glm_no_trend <- glm(data ~ 1, data=Sable_geo_df_binary, family=binomial(link=logit))

summary(sable_glm_trend_1) #all the things are singificant
summary(sable_glm_1_int) #interactions are a thing tho
summary(sable_glm_trend_2_int)#none the things are significant
summary(sable_glm_2_noint) #this one is really good actually. but I;d probably drop LONG^2 if given the option
summary(sable_glm_no_trend) #nope
plot(Sable_geo_binary)

max(Sable_geo_df_binary$LATITUDE)

boxwid <- 1

my_grid <- pred_grid(  #MAKE THE PREDICTED GRID BE NICE ROUND NUMBERS... choose a nult of the boxwidth
  c(-10, 15),
  c(50, 55),
  by=boxwid
) #i think these values are fine



dim(my_grid)

my_variog_sable<- variog(Sable_geo_binary, trend="1st") 
my_variog_sable_2<- variog(Sable_geo_binary, trend="2nd") 

plot(my_variog_sable)
plot(my_variog_sable_2)
#
#both look weird
##gonna roll with trend=1st for now.

##Variofit for the WLS estimate
my_WLS_sable <- variofit(my_variog_sable,
                        ini.cov.pars = c(0.11, 10), #sill, then range estimates
                        cov.model="exponential",
                        fix.nugget=F,
                        max.dist = 300 #plot gets weird after 300
                        )

##plot it over your variog
plot(my_variog_sable)
lines(my_WLS_sable) #looks like a good fit to me.

names(my_WLS_sable)
sable.cov.pars <- my_WLS_sable$cov.pars #sigsq, then phi
sable_WLS_sigsq <- sable.cov.pars[1]
sable_WLS_phi <- sable.cov.pars[2]
sable_WLS_tao_sq <- my_WLS_sable$nugget
sable_WLS_w <- sable_WLS_tao_sq/sable_WLS_sigsq
```


Add other frequentist models?
```{r}
#add other 
```



AND check for spatial autocorrelation!! How to do this again? A variogram??

BACK To BAYESIAN
spGLM
```{r}
#my binary dataframe:
##Sable_geo_df_binary

#phi <- 3/50 #i think I need to find estimates for these
#sigma.sq <- 2


####some other stuff above, not sure how important
m.1 <- spGLM(data~LONGITUDE + LATITUDE, family="binomial", coords=coords, weights=weights, starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1, "w"=0),
                 tuning=list("beta"=beta.tuning, "phi"=0.5, "sigma.sq"=0.5, "w"=0.5),
priors=list("beta.Normal"=list(0,10), "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)), amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                 cov.model="exponential", verbose=TRUE, n.report=10)
```


```{r}
library(spBayes)
?spGLM

m.2 <- spGLM(data~LONGITUDE + LATITUDE, family="binomial", coords=Sable_geo_binary$coords,  starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1), #need to add somehthing here!! ##what is beta starting
                 tuning=list("beta"=beta.tuning, "phi"=0.5, "sigma.sq"=0.5),
priors=list("beta.Normal"=list(0,10), "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)), amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                 cov.model="exponential", verbose=TRUE, n.report=10)
                 
                 
                 
m.3 <- spGLM(data~LONGITUDE + LATITUDE, family="binomial", coords=Sable_geo_binary$coords, data=Sable_geo_df_binary, n.samples = 100, cov.model="exponential",
             starting=list("phi"=0.5,"sigma.sq"=1), priors=list("phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2,1)), tuning=list("phi"=0.5, "sigma.sq"=0.5, "beta"= )) # starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1), #need to add somehthing here!! ##what is beta starting
                # tuning=list("beta"=beta.tuning, "phi"=0.5, "sigma.sq"=0.5),
#priors=list("beta.Normal"=list(0,10), "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)), amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                 #cov.model="exponential", verbose=TRUE, n.report=10)
```

Epiphany: bayesian 04/06/22
p. 37 of spBayes documentation
what does w equal again? sigma/tao?
w=taosq/sigmasq!!!!
```{r}
fit <- glm(data~LONGITUDE + LATITUDE, family=binomial(link=logit), data=Sable_geo_df_binary)
beta.starting <- coef(fit)
beta.tuning <- t(chol(vcov(fit)))

#sable_WLS_phi
#sable_WLS_sigsq

###



n.batch <- 200
batch.length <- 50
n.samples <- n.batch*batch.length

m.4 <- spGLM(data~LONGITUDE + LATITUDE, family="binomial", coords=Sable_geo_binary$coords, data=Sable_geo_df_binary, n.samples = 100, cov.model="exponential",
             starting=list("phi"=sable_WLS_phi,"sigma.sq"=sable_WLS_sigsq, "beta"=beta.starting, "w"= sable_WLS_w), priors=list("phi.Unif"=c(1, 2), "sigma.sq.IG"=c(2,1), 
                                                                                                                                #"beta.Normal"=list(0,10)), 
                                                                                                                          "beta.Normal"=list(c(0,0,0),c(10,10,10))),
             tuning=list("phi"=0.5, "sigma.sq"=0.5, "beta"= beta.tuning, "w" = 0.5), #for metropolis proposals. May need to adjust
  amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                 verbose=TRUE, n.report=10)

#failing because there are repeats at the same location
##try getting rid of these and see if thtat works

#if that doesn't work.. Try getting rid of the super super close location

#if THAT doesn't work... something about the range of the semivariogram, if range parameter is on the big size, locations.... try after the other things

```


04/07/22
Yesterday I figured out my starting values.
I keep getting this code: Cholesky failed in spGLM. This could mean it's failing due to overlapping values. I'll try making a new dataframe without duplicates, find new parameters for this, and basically just run everything again.

Steps:
 1- create new df without duplicates
 2- emprical varigram and WLS parameter estimates
 3- logistic regression, for beta values (GLM)
 4- and then see if the spGLM runs
 
 1. Create new df without duplicates
```{r}
###MESSED UP AT FIRST
#Sable_geo_binary
#Sable_geo_df_binary
library(dplyr)
#Sable_geo_df_bin_noduplicates <- Sable_geo_df_binary %>% distinct(Sable_geo_df_binary$coords) #OK, HERE IS MY NONDUPLICATED GEODATAFRAME
#length(Sable_geo_df_binary[,1]) #1150
#length(Sable_geo_df_bin_noduplicates[,1]) #1148

#that's not working
#R SUGGESTION:
#use dup.coords() to locate duplicated coodiantes
#use jitterDupCoords for jittering replicated locations
#dup.coords(Sable_geo_df_bin_noduplicated)
#length(Sable_geo_binary_noduplicates$data)

##AND THEN SUCCESS WITH THE JITTER
coord.df <-data.frame(Sable_geo_df_binary$LONGITUDE, Sable_geo_df_binary$LATITUDE )
Sable_coord_jitter <- jitterDupCoords(coord.df, max=0.01) #can change max to bigger, see if that changes thigns
Sable_coord_jitter$data <- Sable_geo_df_binary$data

Sable_coord_binary_jitter_gdf <- as.geodata(Sable_coord_jitter)
dup.coords(Sable_coord_binary_jitter_gdf)

```

2. Empirical variogram and WLS to get parameter estimats (sigsq, w(tao/sigsq, i think...), and phi)
```{r}
boxwid <- 1

my_grid <- pred_grid(  
  c(-10, 15),
  c(50, 55),
  by=boxwid
) #These are the same as the grid before



dim(my_grid)

my_variog_sable_jitter<- variog(Sable_coord_binary_jitter_gdf, trend="1st") 
#my_variog_sable_2<- variog(Sable_geo_binary, trend="2nd") 

plot(my_variog_sable_jitter)
#plot(my_variog_sable_2)
#
#both look weird
##gonna roll with trend=1st for now.

##Variofit for the WLS estimate
my_WLS_sable_jitter <- variofit(my_variog_sable_jitter,
                        ini.cov.pars = c(0.11, 7), #sill, then range estimates
                        cov.model="exponential",
                        fix.nugget=F,
                        max.dist = 300 #plot gets weird after 300
                        )

##plot it over your variog
plot(my_variog_sable_jitter)
lines(my_WLS_sable_jitter) #looks like a good fit to me.

names(my_WLS_sable_jitter)
sable.cov.pars_j <- my_WLS_sable_jitter$cov.pars #sigsq, then phi
sable_WLS_sigsq_j <- sable.cov.pars_j[1]
sable_WLS_phi_j <- sable.cov.pars_j[2]
sable_WLS_tao_sq_j <- my_WLS_sable_jitter$nugget
sable_WLS_w_j <- sable_WLS_tao_sq_j/sable_WLS_sigsq_j
```

 3- logistic regression, for beta values (GLM)
```{r}
#using gdf: Sable_coord_binary_jitter_gdf
names(Sable_coord_binary_jitter_gdf)
fit_j <- glm(data~Sable_geo_df_binary.LONGITUDE + Sable_geo_df_binary.LATITUDE, family=binomial(link=logit), data=Sable_coord_binary_jitter_gdf)
beta.starting_j <- coef(fit_j)
beta.tuning_j <- t(chol(vcov(fit_j)))


#got my betas

```

 4- and then see if the spGLM runs
```{r}
#the setup
n.batch <- 200
batch.length <- 50
n.samples <- n.batch*batch.length

n.batch2 <- 50 #shorter, will it work?
batch.length2 <- 10

#the spGLM attempt
m.jitter <- spGLM(data~Sable_geo_df_binary.LONGITUDE + Sable_geo_df_binary.LATITUDE, family="binomial", coords=Sable_coord_binary_jitter_gdf$coords, data=Sable_coord_binary_jitter_gdf, n.samples = 100, cov.model="exponential",
             starting=list("phi"=sable_WLS_phi_j,"sigma.sq"=sable_WLS_sigsq_j, "beta"=beta.starting_j, "w"= sable_WLS_w_j), priors=list("phi.Unif"=c(1, 2), "sigma.sq.IG"=c(2,1), 
                                                                                                              "beta.Normal"=list(c(0,0,0),c(10,10,10))),
             tuning=list("phi"=0.5, "sigma.sq"=0.5, "beta"= beta.tuning_j, "w" = 0.5), #for metropolis proposals. May need to adjust
  amcmc=list("n.batch"=n.batch2, "batch.length"=batch.length2, "accept.rate"=0.43),
                 verbose=TRUE, n.report=10)
```
 
 Seems to be working now -> 04/08/22
 Consider ajusting the jitter
 or other spGLM arguments
 or the semivariogram type


AGAIN!-> delinting the overlap
 1. Create new df without duplicates
```{r}
###MESSED UP AT FIRST
#Sable_geo_binary
#Sable_geo_df_binary
library(splancs)
library(geoR)
library(dplyr)
#Sable_geo_df_bin_noduplicates <- Sable_geo_df_binary %>% distinct(Sable_geo_df_binary$coords) #OK, HERE IS MY NONDUPLICATED GEODATAFRAME
#length(Sable_geo_df_binary[,1]) #1150
#length(Sable_geo_df_bin_noduplicates[,1]) #1148

#that's not working
#R SUGGESTION:
#use dup.coords() to locate duplicated coodiantes
#use jitterDupCoords for jittering replicated locations
#dup.coords(Sable_geo_df_bin_noduplicated)
#length(Sable_geo_binary_noduplicates$data)

##AND THEN SUCCESS WITH THE JITTER
#coord.df <-data.frame(Sable_geo_df_binary$LONGITUDE, Sable_geo_df_binary$LATITUDE )
#Sable_coord_jitter <- jitterDupCoords(coord.df, max=0.01) #can change max to bigger, see if that changes thigns
#Sable_coord_jitter$data <- Sable_geo_df_binary$data

#Sable_coord_binary_jitter_gdf <- as.geodata(Sable_coord_jitter)
#dup.coords(Sable_coord_binary_jitter_gdf)

Sable_geo_distinct <- distinct(Sable_geo_df_binary)
dup.coords(Sable_geo_distinct)
Sable_tmp <- distinct(Sable_geo_distinct[,1:2])
dup.coords(Sable_tmp) #ok so that worked, got my coords
dat <- Sable_geo_distinct$data
length(dat)
dat <- dat[-1148]
length(dat) #got rid of the extra one
Sable_tmp$data <- dat
Sable_geo_distinct_altered <- Sable_tmp  ##LETS ROLL WITH THIS!! ##WHOOHOO

#need to find and delete the duplicate
#Sable_geo_distinct[which(!dup.coords(Sable_geo_distinct$id))]
#Sable_geo_distinct[]
##UGH!!
#remove.duplicates


#ok, back from a break, for just a little bit more coding
#Let's remove those duplicated coords.
#REMVOE "X15585"
#Sable_geo_distinct["X15585",]
#Sable_geo_distinct2 <- Sable_geo_distinct["X15585",]
```

And the rest, with
Sable_geo_distinct_altered
2
3
4
```{r}
boxwid <- 1

my_grid <- pred_grid(  
  c(-10, 15),
  c(50, 55),
  by=boxwid
) #These are the same as the grid before



dim(my_grid)

##ERROR HERE , this is where I stop 4/7/22
class(Sable_geo_distinct_altered)
Sable_geo_alt_matrix <- as.matrix(Sable_geo_distinct_altered[,1:3])
Sable_gdf_alt <- as.geodata(Sable_geo_alt_matrix) #ok. here works

my_variog_sable_altered<- variog(Sable_gdf_alt) 
#my_variog_sable_2<- variog(Sable_geo_binary, trend="2nd") 

plot(my_variog_sable_altered)
#plot(my_variog_sable_2)
#
#both look weird
##gonna roll with trend=1st for now.

##Variofit for the WLS estimate
my_WLS_sable_alt <- variofit(my_variog_sable_altered,
                        ini.cov.pars = c(0.11, 7), #sill, then range estimates
                        cov.model="exponential", #can try changing this to other types of semivariograms eventually
                        fix.nugget=F,
                        max.dist = 300 #plot gets weird after 300
                        )

##plot it over your variog
plot(my_variog_sable_altered)
lines(my_WLS_sable_alt) #looks like a good fit to me.

names(my_WLS_sable_alt)
sable.cov.pars_alt <- my_WLS_sable_alt$cov.pars #sigsq, then phi
sable_WLS_sigsq_alt <- sable.cov.pars_alt[1]
sable_WLS_phi_alt <- sable.cov.pars_alt[2]
sable_WLS_tao_sq_alt <- my_WLS_sable_alt$nugget
sable_WLS_w_alt <- sable_WLS_tao_sq_alt/sable_WLS_sigsq_alt
```

Sable_geo_alt_matrix -> main gdf right now
 3- logistic regression, for beta values (GLM)
 Sable_gdf_alt 
 
```{r}
#using gdf: Sable_coord_binary_jitter_gdf
names(Sable_gdf_alt) 
fit_a <- glm(data~LONGITUDE + LATITUDE, family=binomial(link=logit), data=Sable_gdf_alt)
beta.starting_a <- coef(fit_a)
beta.tuning_a <- t(chol(vcov(fit_a)))


#got my betas for the altered version

```

 4- and then see if the spGLM runs
 gdf: Sable_gdf_alt 
```{r}
#the setup
n.batch <- 200
batch.length <- 50
n.samples <- n.batch*batch.length

library(spBayes)
#the spGLM attempt
m.alt <- spGLM(data~LONGITUDE + LATITUDE, family="binomial", coords=Sable_gdf_alt$coords, #this might have been an error in the last one...
               data=Sable_gdf_alt, n.samples = 100, cov.model="gaussian",
             starting=list("phi"=sable_WLS_phi_alt,"sigma.sq"=sable_WLS_sigsq_alt, "beta"=beta.starting_a, "w"= sable_WLS_w_alt), priors=list("phi.Unif"=c(1, 2), "sigma.sq.IG"=c(2,1), 
                                                                                                              "beta.Normal"=list(c(0,0,0),c(10,10,10))),
             tuning=list("phi"=0.5, "sigma.sq"=0.5, "beta"= beta.tuning_a, "w" = 0.5), #another potential jitter error
             #for metropolis proposals. May need to adjust
  amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                 verbose=TRUE, n.report=10)
```

